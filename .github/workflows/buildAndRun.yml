
name: Build et Vérification de Lancement du Projet JS

on:
  push:
    branches:
      - main # Déclenche le workflow à chaque push sur la branche 'main'
      - develop # Si vous utilisez une branche de développement
  pull_request:
    branches:
      - main # Déclenche pour les Pull Requests ciblant 'main'
      - develop # Si vous utilisez une branche de développement

jobs:
  build_and_start:
    runs-on: ubuntu-latest # Utilise la dernière version d'Ubuntu pour l'environnement d'exécution

    steps:
    - name: Vérifier le code # Étape 1: Cloner le dépôt GitHub
      uses: actions/checkout@v4

    - name: Configurer Node.js # Étape 2: Configurer l'environnement Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20' # IMPORTANT: Adaptez à votre version de Node.js (ex: 18, 20, 22)
        cache: 'npm' # Active le cache pour les dépendances npm

    - name: Installer les dépendances # Étape 3: Installer les packages npm
      run: npm ci

    - name: Lancer le build (si applicable) # Étape 4: Exécuter la commande de build
      # Cette étape est optionnelle et dépend de votre projet.
      # Si votre projet n'a pas de "build step" pour la production (par ex. un simple backend Node.js sans frontend à compiler),
      # vous pouvez supprimer ou commenter cette étape.
      # Si vous avez un frontend (React, Vue, Angular) ou une transpilation (TypeScript),
      # cette commande est généralement `npm run build`.
      run: npm run dev
      # Continue sur erreur, car parfois un build peut échouer et on veut quand même essayer de lancer le service
      # continue-on-error: true

    - name: Démarrer le serveur et vérifier # Étape 5: Lancer le serveur et vérifier s'il écoute
      # Nous allons lancer le serveur en arrière-plan et le tester avec curl
      run: |
        # 1. Définir les variables d'environnement nécessaires au démarrage
        # Si votre serveur a besoin de DATABASE_URL, JWT_SECRET, PORT, etc. pour démarrer,
        # vous devez les définir ici. Utilisez les secrets GitHub pour les valeurs sensibles.
        # Exemple:
        export DATABASE_URL=${{ secrets.DATABASE_URL }}
        export JWT_SECRET=${{ secrets.JWT_SECRET }}
        export PORT=3000 # Utilisez le port que votre serveur écoute

        # 2. Lancer le serveur en arrière-plan
        # Assurez-vous que votre commande de démarrage est correcte (ex: node server.js ou npm start)
        # La sortie est redirigée pour éviter que les logs ne polluent le terminal du workflow.
        # Le `&` à la fin lance le processus en arrière-plan.
        npm start &

        # 3. Attendre que le serveur démarre
        # Ceci est crucial. Le serveur prend du temps à s'initialiser et à écouter sur le port.
        # On attend une ou plusieurs secondes avant de tenter de se connecter.
        echo "En attente du démarrage du serveur..."
        sleep 5 # Attendre 5 secondes. Ajustez si votre serveur prend plus ou moins de temps.

        # 4. Vérifier que le serveur est bien en cours d'exécution
        # Utilisez 'curl' pour tenter de se connecter à une route accessible de votre API.
        # Si votre API a une route de "health check" (ex: /health ou /status), c'est l'idéal.
        # Sinon, vous pouvez tenter de vous connecter à la route racine / ou à une autre route publique.
        echo "Tentative de connexion au serveur..."
        curl --fail http://localhost:3000/ # ou http://localhost:3000/api/health
        # La commande '--fail' fera échouer l'étape si le code de statut HTTP n'est pas 2xx/3xx.

        echo "Serveur démarré et accessible !"

      # Si vous avez des services qui restent ouverts (comme Prisma), vous pourriez voir
      # des messages de "process not exiting gracefully". Pour une simple vérification de démarrage,
      # ce n'est pas toujours critique, mais pour des tests plus approfondis, il faudrait les fermer.
